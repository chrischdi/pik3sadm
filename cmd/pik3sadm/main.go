package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"path"
	"strings"
	"text/template"

	"github.com/chrischdi/pik3s/pkg/executor"

	"gopkg.in/yaml.v2"
	"k8s.io/klog"
)

var configFile = flag.String("config", "/boot/pik3sadm.yaml", "path to the PiK3SAdmConfig file")
var dryRun = flag.Bool("dryRun", false, "only do a dry run")
var phases = flag.String("phases", "prepare-system,mounts,k3s", "which phases to execute")

var defaultPhases = map[string]bool{
	"prepare-system": false,
	"mounts":         false,
	"k3s":            false,
}

const (
	autoGeneratedHeader     = "THIS FILE WAS AUTOGENERATED USING pik3sadm"
	autoGeneratedStart      = "AUTOGENERATED START"
	autoGeneratedEnd        = "AUTOGENERATED END"
	autoGeneratedHeaderHash = "# " + autoGeneratedHeader + "\n# " + autoGeneratedStart
	autoGeneratedFooterHash = "# " + autoGeneratedEnd + "\n"
)

type PiK3SAdmConfig struct {
	Hostname string `yaml:"hostname"`

	// Network allows to configure eth or wifi networking
	Network NetworkOptions `yaml:"network"`

	// SSHPublicKey gets added to the user kube to allow ssh access
	SSHPublicKeys []string `yaml:"ssh_public_keys"`

	Phases map[string]bool

	Mounts []MountOption `yaml:"mounts"`

	K3s K3sOptions `yaml:"k3s"`
}

type NetworkOptions struct {
	IPAddress string   `yaml:"ip_address"`
	Gateway   string   `yaml:"gateway"`
	DNS       []string `yaml:"dns"`

	WifiSSID       string `yaml:"wifi_ssid"`
	WPA2Passphrase string `yaml:"wpa2_passphrase"`
}

type MountOption struct {
	Device      string      `yaml:"device"`
	Destination string      `yaml:"destination"`
	Filesystem  string      `yaml:"filesystem"`
	BindMounts  []BindMount `yaml:"bind_mounts"`
}

type BindMount struct {
	Source      string `yaml:"source"`
	Destination string `yaml:"destination"`
}

type K3sOptions struct {
	Master    bool   `yaml:"master"`
	MasterUrl string `yaml:"master_url"`
	JoinToken string `yaml:"join_token"`
}

func main() {
	klog.InitFlags(nil)
	flag.Set("v", "3")

	flag.Parse()

	if *configFile == "" {
		klog.Fatal("paramenter 'config' is mandatory")
	}

	adm := NewPiK3sAdm(*configFile, *dryRun)
	if err := adm.Init(); err != nil {
		klog.Fatal(err)
	}

	klog.Info("pik3sadm was successful")
}

func readConfig(path, phases string) (*PiK3SAdmConfig, error) {
	klog.V(3).Infof("reading config file from %s", path)
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("error reading config at %s: %v", *configFile, err)
	}

	c := &PiK3SAdmConfig{Phases: map[string]bool{}}
	err = yaml.Unmarshal([]byte(data), c)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling config: %v", err)
	}

	p := strings.Split(phases, ",")
	for _, phase := range p {
		if _, ok := defaultPhases[phase]; !ok {
			return nil, fmt.Errorf("unknown phase %s", phase)
		}
		c.Phases[phase] = true
	}

	return c, nil
}

type PiK3sAdm struct {
	c *PiK3SAdmConfig
	e executor.Executor
}

func NewPiK3sAdm(configFile string, dryRun bool) *PiK3sAdm {
	adm := &PiK3sAdm{}
	if dryRun {
		adm.e = executor.NewDummyExecutor()
	} else {
		adm.e = executor.NewExecutor()
	}

	var err error
	adm.c, err = readConfig(configFile, *phases)
	if err != nil {
		klog.Fatal(err)
	}

	return adm
}

func (a *PiK3sAdm) Init() error {
	// prepare-system phase
	if a.c.Phases["prepare-system"] {
		if err := a.PrepareSystemPhase(); err != nil {
			return fmt.Errorf("error running phase 'prepare-system': %v", err)
		}
	}

	// mounts phase
	if a.c.Phases["mounts"] {
		if err := a.MountsPhase(); err != nil {
			return fmt.Errorf("error running phase 'mounts': %v", err)
		}
	}

	// k3s phase
	if a.c.Phases["k3s"] {
		if err := a.K3sPhase(); err != nil {
			return fmt.Errorf("error running phase 'k3s': %v", err)
		}
	}

	return nil
}

func (a *PiK3sAdm) PrepareSystemPhase() error {
	klog.Info("[prepare-system] setting hostname")
	if err := setHostname(a.e, a.c.Hostname); err != nil {
		return err
	}

	klog.Info("[prepare-system] perparing /etc/hosts")
	if err := configureHosts(a.e, a.c.Hostname, a.c.Network.IPAddress); err != nil {
		return err
	}

	klog.Info("[prepare-system] configuring network")
	if err := configureNetwork(a.e, &a.c.Network); err != nil {
		return err
	}

	klog.Info("[prepare-system] configuring ssh public key for user kube")
	if err := configureSSHPublicKey(a.e, strings.Join(a.c.SSHPublicKeys, "\n")); err != nil {
		return err
	}
	return nil
}

func (a *PiK3sAdm) MountsPhase() error {
	for _, mount := range a.c.Mounts {
		klog.Infof("[mounts] mounting device %s to %s", mount.Device, mount.Destination)
		if _, err := a.e.Stat(mount.Device); err != nil {
			return fmt.Errorf("error on os.Stat %s: %v", mount.Device, err)
		}

		if err := a.mountDevice(mount.Device, mount.Destination, mount.Filesystem, ""); err != nil {
			return err
		}

		for _, bindMount := range mount.BindMounts {
			klog.Infof("[mounts] bindmounting %s to %s", bindMount.Source, bindMount.Destination)
			if err := a.e.Command("mkdir", "-p", bindMount.Source, bindMount.Destination); err != nil {
				return err
			}
			realSource := path.Join(mount.Destination, bindMount.Source)
			if err := a.mountDevice(realSource, bindMount.Destination, "none", "bind"); err != nil {
				return err
			}
		}

	}

	return nil
}

func (a *PiK3sAdm) K3sPhase() error {
	var args []string

	klog.Infof("[k3s] downloading k3s install script")
	if err := a.e.Command("curl", "-o", "/usr/local/bin/k3s.sh", "-sfL", "https://get.k3s.io"); err != nil {
		return err
	}

	klog.Infof("[k3s] making k3s install executable")
	if err := a.e.Command("chmod", "+x", "/usr/local/bin/k3s.sh"); err != nil {
		return err
	}

	klog.Infof("[k3s] running k3s install script")
	if a.c.K3s.Master {
		args = []string{"INSTALL_K3S_EXEC=server --no-deploy=traefik --no-deploy=servicelb --no-deploy coredns"}
	} else {
		if a.c.K3s.MasterUrl == "" || a.c.K3s.JoinToken == "" {
			return fmt.Errorf("to join a cluster the k3s url and token must be not empty")
		}
		args = []string{
			fmt.Sprintf("K3S_URL=%s", a.c.K3s.MasterUrl),
			fmt.Sprintf("K3S_TOKEN=%s", a.c.K3s.JoinToken),
		}
	}

	_, err := a.e.CommandEnv("/usr/local/bin/k3s.sh", args)
	return err
}

func setHostname(exec executor.Executor, hostname string) error {
	cmd := "hostnamectl"
	args := []string{"set-hostname", hostname}
	return exec.Command(cmd, args...)
}

func configureHosts(exec executor.Executor, hostname, ipAddress string) error {
	t := template.Must(template.New("tpl").Parse(networkHostsConfig))
	buf := bytes.NewBufferString("")
	if err := t.Execute(buf, networkHostsHelper{hostname, ipAddress}); err != nil {
		return fmt.Errorf("error executing /etc/hosts template: %v", err)
	}
	if err := exec.WriteFile("/etc/hosts", buf.Bytes(), 0644); err != nil {
		return err
	}

	return nil
}

func configureNetwork(exec executor.Executor, opts *NetworkOptions) error {
	// stop netctl for eth0 and wlan0
	if err := exec.Command("systemctl", "stop", "netctl@eth0", "netctl@wlan0"); err != nil {
		return err
	}

	// disable netctl for eth0 and wlan0
	if err := exec.Command("systemctl", "disable", "netctl@eth0", "netctl@wlan0"); err != nil {
		return err
	}

	if err := exec.Command("systemctl", "stop", "systemd-resolved"); err != nil {
		return err
	}

	if err := exec.Command("systemctl", "disable", "systemd-resolved"); err != nil {
		return err
	}

	// // write config for systemd-resolved
	// t := template.Must(template.New("tpl").Parse(networkSystemdResolvedConfig))
	// buf := bytes.NewBufferString("")
	// if err := t.Execute(buf, opts); err != nil {
	// 	return fmt.Errorf("error executing systemd-resolved template: %v", err)
	// }
	// if err := exec.WriteFile("/etc/systemd/resolved.conf", buf.Bytes(), 0644); err != nil {
	// 	return err
	// }

	// if err := exec.Command("systemctl", "restart", "systemd-resolved"); err != nil {
	// 	return err
	// }

	// if err := exec.Command("ln", "-sf", "/run/systemd/resolve/stub-resolv.conf", "/etc/resolv.conf"); err != nil {
	// 	return err
	// }

	// write config for systemd-resolved
	t := template.Must(template.New("tpl").Parse(networkResolvConfConfig))
	buf := bytes.NewBufferString("")
	if err := t.Execute(buf, opts); err != nil {
		return fmt.Errorf("error executing systemd-resolved template: %v", err)
	}
	if err := exec.WriteFile("/etc/resolv.conf", buf.Bytes(), 0644); err != nil {
		return err
	}

	// write config for eth0
	t = template.Must(template.New("tpl").Parse(networkInterfaceEthConfigTemplate))
	buf = bytes.NewBufferString("")
	if err := t.Execute(buf, opts); err != nil {
		return fmt.Errorf("error executing network interface template: %v", err)
	}
	if err := exec.WriteFile("/etc/systemd/network/eth.network", buf.Bytes(), 0644); err != nil {
		return err
	}

	// configure wifi
	if opts.WifiSSID != "" {
		// write config for wlan0
		if err := exec.WriteFile("/etc/systemd/network/wifi.network", []byte(networkInterfaceWifiConfig), 0644); err != nil {
			return err
		}

		// generate config for wpa_supplicant
		out, err := exec.CommandStdout("wpa_passphrase", opts.WifiSSID, opts.WPA2Passphrase)
		if err != nil {
			return err
		}

		out = []byte(autoGeneratedHeaderHash + "\n" + string(out) + "\n" + autoGeneratedFooterHash)
		// write config for wpa_supplicant
		if err := exec.WriteFile("/etc/wpa_supplicant/wpa_supplicant-wlan0.conf", out, 0600); err != nil {
			return err
		}

		// enable wpa_supplicant for wlan0
		if err := exec.Command("systemctl", "enable", "wpa_supplicant@wlan0"); err != nil {
			return err
		}

		// start wpa_supplicant for wlan0
		if err := exec.Command("systemctl", "start", "wpa_supplicant@wlan0"); err != nil {
			return err
		}
	}

	// restart service systemd-networkd
	if err := exec.Command("systemctl", "restart", "systemd-networkd"); err != nil {
		return err
	}

	// restart service sshd
	return exec.Command("systemctl", "restart", "sshd")
}

func configureSSHPublicKey(exec executor.Executor, publicKey string) error {
	if err := exec.Command("mkdir", "-p", "/home/kube/.ssh"); err != nil {
		return err
	}

	if err := exec.WriteFile("/home/kube/.ssh/authorized_keys", []byte(publicKey), 0600); err != nil {
		return err
	}

	return exec.Command("chown", "kube:kube", "/home/kube/.ssh/authorized_keys")
}

func (a *PiK3sAdm) mountDevice(what string, where string, fsType string, options string) error {
	t := template.Must(template.New("mount").Parse(mountTemplate))

	opts := mountTemplateHelper{what, where, fsType, options}

	buf := bytes.NewBufferString("")
	if err := t.Execute(buf, opts); err != nil {
		return fmt.Errorf("error executing systemd-mount template: %v", err)
	}

	unitName := fmt.Sprintf("%s.mount", strings.ReplaceAll(strings.TrimPrefix(where, "/"), "/", "-"))

	if err := a.e.WriteFile("/etc/systemd/system/"+unitName, buf.Bytes(), 0644); err != nil {
		return err
	}

	if err := a.e.Command("systemctl", "daemon-reload"); err != nil {
		return err
	}

	if err := a.e.Command("systemctl", "enable", unitName); err != nil {
		return err
	}

	if err := a.e.Command("systemctl", "start", unitName); err != nil {
		return err
	}

	return nil
}

// /etc/systemd/network/eth.network
const networkInterfaceEthConfigTemplate = autoGeneratedHeaderHash + `
[Match]
Name=eth*

[Network]
Address={{ .IPAddress }}/24
Gateway={{ .Gateway }}
{{- range $_, $srv := .DNS }}
DNS={{ $srv }}
{{- end }}
IPMasquerade=yes
IPForward=kernel
` + autoGeneratedFooterHash

// /etc/systemd/network/wifi.network
const networkInterfaceWifiConfig = autoGeneratedHeaderHash + `
[Match]
Name=wlan* wlp*

[Network]
DHCP=yes
RouteMetric=10
IPv6PrivacyExtensions=true
IPMasquerade=yes
IPForward=kernel
` + autoGeneratedFooterHash

type networkHostsHelper struct {
	Hostname  string
	IPAddress string
}

const networkHostsConfig = autoGeneratedHeaderHash + `
127.0.0.1 localhost.localdomain localhost
::1 ipv6-localhost ipv6-localhost
{{ .IPAddress }} {{ .Hostname }}
` + autoGeneratedFooterHash

const networkSystemdResolvedConfig = autoGeneratedHeaderHash + `
# See resolved.conf(5) for details
[Resolve]
DNS=
{{- range $index, $element := .DNS -}}
{{- if $index }} {{ end -}}
	{{- $element -}}
{{- end }}

` + autoGeneratedFooterHash

const networkResolvConfConfig = autoGeneratedHeaderHash + `
{{- range $_, $srv := .DNS }}
nameserver {{ $srv }}
{{- end }}

` + autoGeneratedFooterHash

type mountTemplateHelper struct {
	What    string
	Where   string
	Type    string
	Options string
}

const mountTemplate = autoGeneratedHeaderHash + `
[Unit]
Before=local-fs.target

[Mount]
What={{ .What }}
Where={{ .Where }}
Type={{ .Type }}
Options={{ .Options }}

[Install]
WantedBy=local-fs.target
` + autoGeneratedFooterHash
